<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Scope collection - The Shackle Almanac</title>


        <!-- Custom HTML head -->
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script
        	id="MathJax-script"
        	async
        	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
        ></script>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../foreword.html">The Shackle Almanac</a></li><li class="chapter-item expanded "><a href="../../process.html"><strong aria-hidden="true">1.</strong> The compilation process</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../compilation/parsing.html"><strong aria-hidden="true">1.1.</strong> Parsing</a></li><li class="chapter-item expanded "><a href="../../compilation/ast/ast.html"><strong aria-hidden="true">1.2.</strong> Abstract syntax tree</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../compilation/ast/includes.html"><strong aria-hidden="true">1.2.1.</strong> Include resolution</a></li></ol></li><li class="chapter-item expanded "><a href="../../compilation/hir/hir.html"><strong aria-hidden="true">1.3.</strong> High-level intermediate representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../compilation/hir/scope.html" class="active"><strong aria-hidden="true">1.3.1.</strong> Scope collection</a></li><li class="chapter-item expanded "><a href="../../compilation/hir/typecheck.html"><strong aria-hidden="true">1.3.2.</strong> Type checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../compilation/thir/thir.html"><strong aria-hidden="true">1.4.</strong> Typed high-level intermediate representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../compilation/thir/transform.html"><strong aria-hidden="true">1.4.1.</strong> Model transformations</a></li><li class="chapter-item expanded "><a href="../../compilation/thir/type-specialise.html"><strong aria-hidden="true">1.4.2.</strong> Type specialisation</a></li><li class="chapter-item expanded "><a href="../../compilation/thir/overloading.html"><strong aria-hidden="true">1.4.3.</strong> Removal of overloading</a></li><li class="chapter-item expanded "><a href="../../compilation/thir/records.html"><strong aria-hidden="true">1.4.4.</strong> Erasure of records</a></li><li class="chapter-item expanded "><a href="../../compilation/thir/enums.html"><strong aria-hidden="true">1.4.5.</strong> Erasure of enums</a></li><li class="chapter-item expanded "><a href="../../compilation/thir/comprehension.html"><strong aria-hidden="true">1.4.6.</strong> Desugaring of comprehensions</a></li><li class="chapter-item expanded "><a href="../../compilation/thir/option-types.html"><strong aria-hidden="true">1.4.7.</strong> Erasure of option types</a></li><li class="chapter-item expanded "><a href="../../compilation/thir/captures.html"><strong aria-hidden="true">1.4.8.</strong> Desugaring of capturing</a></li></ol></li><li class="chapter-item expanded "><a href="../../compilation/mir/mir.html"><strong aria-hidden="true">1.5.</strong> Mid-level intermediate representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../compilation/mir/totalise.html"><strong aria-hidden="true">1.5.1.</strong> Totalisation</a></li><li class="chapter-item expanded "><a href="../../compilation/mir/context.html"><strong aria-hidden="true">1.5.2.</strong> Context analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../../compilation/bytecode-gen.html"><strong aria-hidden="true">1.6.</strong> Bytecode generation</a></li><li class="chapter-item expanded "><a href="../../compilation/interpreter.html"><strong aria-hidden="true">1.7.</strong> Bytecode interpretation</a></li></ol></li><li class="chapter-item expanded "><a href="../../microzinc.html"><strong aria-hidden="true">2.</strong> MicroZinc specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../microzinc/types.html"><strong aria-hidden="true">2.1.</strong> Typing Rules</a></li><li class="chapter-item expanded "><a href="../../microzinc/semantics.html"><strong aria-hidden="true">2.2.</strong> Operational Semantics</a></li></ol></li><li class="chapter-item expanded "><a href="../../interpreter.html"><strong aria-hidden="true">3.</strong> The MicroZinc Interpreter</a></li><li class="chapter-item expanded "><a href="../../mzn-syntax.html"><strong aria-hidden="true">4.</strong> MiniZinc Syntax Changes</a></li><li class="chapter-item expanded "><a href="../../error-handling.html"><strong aria-hidden="true">5.</strong> Error handling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Shackle Almanac</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scope-collection"><a class="header" href="#scope-collection">Scope collection</a></h1>
<p>Scope collection gives the identifiers in scope for each expression in an item. Note that at this point, we don't
perform name resolution, as resolving call identifiers requires the types of the arguments to perform function
overloading resolution, and resolving record field access requires knowledge of the accessed record's type.</p>
<p>It would be possible to only keep track of this for expressions which are identifiers, rather than all expressions
(and we could even perform name resolution for variables and non-overloaded function calls). However, having the scopes
computed for every expression is useful for providing code completion information in the language server.</p>
<h2 id="scope-collection-results"><a class="header" href="#scope-collection-results">Scope collection results</a></h2>
<p>Scope collection results in a data structure containing an arena of <code>Scope</code>s which contain the identifiers defined in
each scope in an item. Each <code>Scope</code> keeps track of its parent <code>Scope</code> index, so that the chain of scopes can be followed
to resolve an identifier. Each expression index in an item is mapped to a scope index and generation (see below for
details on generations).</p>
<p>The <code>db.lookup_item_scope(item_ref)</code> query produces a <code>ScopeResult</code> which allows for easy lookup of functions and
variables in scope for an expression. It automatically traverses the item scopes and will bubble up to global scope
to find an identifier. Note that the result of looking up identifiers is a <code>PatternRef</code> (or list of them for overloaded
functions). These point to the declaring identifier pattern of the identifier (as there may be several identifiers
declared in a single item, via destructuring or in a let expression, so it is not sufficient to give only the item).</p>
<h2 id="scopes-and-generations"><a class="header" href="#scopes-and-generations">Scopes and generations</a></h2>
<p>A <code>Scope</code> keeps track of the variables and functions declared in a particular scope, along with the the parent scope (if
any). For example:</p>
<pre><code class="language-mzn">function foo(int: a) =
    let {
        int: x = 3 * a;
        int: y = x + 2;
    } in a + y;
</code></pre>
<p>Has two scopes: one created by the function item for its body, and one created by the let item.</p>
<p>The first scope contains a declaration for the identifier <code>a</code> and its parent scope (assuming this is a top-level item)
is the global scope. The second scope has declarations for the identifiers <code>x</code> and <code>y</code>, and its parent scope is the
first scope.</p>
<p>Then, the scope for the outer let would be computed to be the first scope, while the scope for the RHS of <code>x</code>, the
RHS of <code>y</code>, and the <code>in</code> expression <code>a + y</code> would be the second scope (and all of their sub-expressions would also
be assigned to be the second scope).</p>
<p>Note that items in let expressions are such that they only enter into scope once they appear, so an item cannot refer to
an item later than itself. For example:</p>
<pre><code class="language-mzn">let {
    int: y = 10;
    int: z = let {
        int: x = y;
        int: y = 1;
    } in x;
} in z
</code></pre>
<p>Will give <code>z = 10</code> as the let item <code>int: y = 1</code> is not in scope for the declaration of <code>x</code>.</p>
<p>This is achieved by keeping track of the 'generation' where a let-item identifier has been declared. The generation is
incremented every time we visit an identifier pattern which creates a new variable. It should also be noted that the
patterns for a declaration in a let are always visited after processing their RHS. Expressions are then assigned both
a scope, along with a generation defining the minimum generation an identifier must be to be considered available in
the expression. Exiting a scope restores the generation the value it had upon entering the scope.</p>
<p>Following the example:</p>
<ul>
<li>The declaration <code>int: y = 10;</code> is visited
<ul>
<li>The RHS expression (<code>10</code>) is assigned scope 0, gen 0</li>
<li>The LHS identifier <code>y</code> is assigned scope 0, gen 1</li>
</ul>
</li>
<li>The declaration <code>int: z = let { int: x = y; int: y = 1; } in x</code> is visited
<ul>
<li>The RHS <code>let</code> expression is assigned scope 0, gen 1
<ul>
<li>The declaration <code>int: x = y;</code> is visited
<ul>
<li>The RHS expression <code>y</code> is assigned scope 1, gen 1</li>
<li>The LHS identifier <code>x</code> is assigned scope 1, gen 2</li>
</ul>
</li>
<li>The declaration <code>int: y = 1</code> is visited
<ul>
<li>The RHS expression <code>1</code> is assigned scope 1, gen 2</li>
<li>The LHS identifier <code>y</code> is assigned scope 1, gen 3</li>
</ul>
</li>
<li>The <code>in</code> expression <code>x</code> is assigned scope 1, gen 3</li>
</ul>
</li>
<li>The LHS identifier <code>z</code> is assigned scope 0, gen 1 (restored because exited scope 1)</li>
</ul>
</li>
<li>The <code>in</code> expression <code>z</code> is assigned scope 0, gen 1</li>
</ul>
<p>From this, we can see that while the RHS of <code>int: x = y</code> is scope 1, since its generation is 1, the <code>y</code> does not refer
to the <code>y</code> in scope 1 (which is generation 3), and so instead refers to the <code>y</code> in scope 0 (which is generation 1).</p>
<p>It should be noted that the 'generation' values are an implementation detail - what actually matters in the end is to
be able to determine whether or not an identifier is in scope or not for a given expression.</p>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<p>Patterns used for variable or parameter declarations are only allowed to contain tuples, records and identifiers.
Otherwise, the pattern is refutable and may not match all values. Identifiers in variable declarations always create
new variables, and do not refer to enumeration/annotation atoms (instead they get shadowed).</p>
<pre><code class="language-mzn">enum Foo = {A, B};

% OK: creates variables `x`, `y` and `z`.
any: (x, (foo: y, bar: z)) = (1, (foo: 2, bar: 3));

% OK: shadows enum values `A` and `B`
any: z = let {
    int: A = 1;
    int: B = 2;
} in A + B;

% ERROR: refutable pattern may not match all cases.
any: (m, 1) = (3, 2);
</code></pre>
<p>In comprehension generators and case expressions, all patterns are allowed, and identifiers can either refer to
enumeration/annotation atoms, or if none match, they create new variables. A problem with this approach is that
since we don't have namespacing, a user could create an atom with the same name as a variable binding in a case
expression or generator in another part of the code, and then that variable binding would instead match that atom,
changing the behaviour (likely causing the model to fail type checking).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../compilation/hir/hir.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../compilation/hir/typecheck.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../compilation/hir/hir.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../compilation/hir/typecheck.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/mzn-highlight.js"></script>


    </div>
    </body>
</html>
