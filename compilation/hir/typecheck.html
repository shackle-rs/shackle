<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type checking - The Shackle Almanac</title>


        <!-- Custom HTML head -->
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script
        	id="MathJax-script"
        	async
        	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
        ></script>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../foreword.html">The Shackle Almanac</a></li><li class="chapter-item expanded "><a href="../../process.html"><strong aria-hidden="true">1.</strong> The compilation process</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../compilation/parsing.html"><strong aria-hidden="true">1.1.</strong> Parsing</a></li><li class="chapter-item "><a href="../../compilation/ast/ast.html"><strong aria-hidden="true">1.2.</strong> Abstract syntax tree</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../compilation/ast/includes.html"><strong aria-hidden="true">1.2.1.</strong> Include resolution</a></li></ol></li><li class="chapter-item expanded "><a href="../../compilation/hir/hir.html"><strong aria-hidden="true">1.3.</strong> High-level intermediate representation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../compilation/hir/scope.html"><strong aria-hidden="true">1.3.1.</strong> Scope collection</a></li><li class="chapter-item expanded "><a href="../../compilation/hir/typecheck.html" class="active"><strong aria-hidden="true">1.3.2.</strong> Type checking</a></li></ol></li><li class="chapter-item "><a href="../../compilation/thir/thir.html"><strong aria-hidden="true">1.4.</strong> Typed high-level intermediate representation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../compilation/thir/transform.html"><strong aria-hidden="true">1.4.1.</strong> Model transformations</a></li><li class="chapter-item "><a href="../../compilation/thir/output.html"><strong aria-hidden="true">1.4.2.</strong> Output item removal</a></li><li class="chapter-item "><a href="../../compilation/thir/domains.html"><strong aria-hidden="true">1.4.3.</strong> Generating constraints for domains</a></li><li class="chapter-item "><a href="../../compilation/thir/top-down-types.html"><strong aria-hidden="true">1.4.4.</strong> Top-down typing</a></li><li class="chapter-item "><a href="../../compilation/thir/type-specialise.html"><strong aria-hidden="true">1.4.5.</strong> Type specialisation</a></li><li class="chapter-item "><a href="../../compilation/thir/dispatch.html"><strong aria-hidden="true">1.4.6.</strong> Generation of function dispatch preambles</a></li><li class="chapter-item "><a href="../../compilation/thir/records.html"><strong aria-hidden="true">1.4.7.</strong> Erasure of records</a></li><li class="chapter-item "><a href="../../compilation/thir/enums.html"><strong aria-hidden="true">1.4.8.</strong> Erasure of enums</a></li><li class="chapter-item "><a href="../../compilation/thir/comprehension.html"><strong aria-hidden="true">1.4.9.</strong> Desugaring of comprehensions</a></li><li class="chapter-item "><a href="../../compilation/thir/option-types.html"><strong aria-hidden="true">1.4.10.</strong> Erasure of option types</a></li><li class="chapter-item "><a href="../../compilation/thir/overloading.html"><strong aria-hidden="true">1.4.11.</strong> Removal of overloading</a></li><li class="chapter-item "><a href="../../compilation/thir/captures.html"><strong aria-hidden="true">1.4.12.</strong> Desugaring of capturing</a></li></ol></li><li class="chapter-item "><a href="../../compilation/mir/mir.html"><strong aria-hidden="true">1.5.</strong> Mid-level intermediate representation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../compilation/mir/totalise.html"><strong aria-hidden="true">1.5.1.</strong> Totalisation</a></li><li class="chapter-item "><a href="../../compilation/mir/context.html"><strong aria-hidden="true">1.5.2.</strong> Context analysis</a></li></ol></li><li class="chapter-item "><a href="../../compilation/bytecode-gen.html"><strong aria-hidden="true">1.6.</strong> Bytecode generation</a></li><li class="chapter-item "><a href="../../compilation/interpreter.html"><strong aria-hidden="true">1.7.</strong> Bytecode interpretation</a></li></ol></li><li class="chapter-item "><a href="../../microzinc.html"><strong aria-hidden="true">2.</strong> MicroZinc specification</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../microzinc/types.html"><strong aria-hidden="true">2.1.</strong> Typing Rules</a></li><li class="chapter-item "><a href="../../microzinc/semantics.html"><strong aria-hidden="true">2.2.</strong> Operational Semantics</a></li></ol></li><li class="chapter-item "><a href="../../interpreter.html"><strong aria-hidden="true">3.</strong> The MicroZinc Interpreter</a></li><li class="chapter-item "><a href="../../mzn-syntax.html"><strong aria-hidden="true">4.</strong> MiniZinc Syntax Changes</a></li><li class="chapter-item "><a href="../../error-handling.html"><strong aria-hidden="true">5.</strong> Error handling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Shackle Almanac</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-checking"><a class="header" href="#type-checking">Type checking</a></h1>
<p>The type-checker performs bottom-up typing of expressions, and checks that the types are correct. This is performed on a
per-item basis. The type-checker deals with 'signatures' and 'bodies' of items separately. Signatures give the type
information needed to compute the type of an expression referring to the item. Typing a body involves typing the rest of
the item (generally this is the annotations and the RHS).</p>
<p>Consider the items:</p>
<pre><code class="language-mzn">function float: foo(int: x :: my_ann) = x + 0.5;
1..3: a = 23;
any: b = foo(a);
</code></pre>
<ul>
<li><code>foo</code> has a signature of <code>function float: foo(int)</code>. Its RHS of <code>x + 0.5</code> is typed separately and verified against the
signature return type, along with the annotation <code>my_ann</code>.</li>
<li><code>a</code> has a signature of <code>int: a</code>, which is computed using only the LHS of the declaration as the type is complete. The
RHS of <code>23</code> is typed separately and verified against the signature type.</li>
<li><code>b</code> uses an <code>any</code> type and so its signature of <code>float: b</code> is computed using the RHS.</li>
</ul>
<h2 id="type-checker-results"><a class="header" href="#type-checker-results">Type checker results</a></h2>
<p>Type checking an item produces several maps containing the computed types. The <code>TypeResult</code> provides access to all types
for an item, by using the signature types and the body types as needed. This can be obtained using the
<code>db.lookup_item_types(item_ref)</code> query.</p>
<ul>
<li>Indexing using an <code>ArenaIndex&lt;Expression&gt;</code> gives the <code>Ty</code> of the expression.
<ul>
<li>E.g. the expression <code>{1, 1.5}</code> will have type <code>set of float</code>.</li>
</ul>
</li>
<li>Indexing using an <code>ArenaIndex&lt;Pattern&gt;</code> gives the <code>PatternTy</code> of the pattern.
<ul>
<li>The <code>PatternTy</code> includes information about what the pattern is being used for, rather than just the type of the
pattern itself (e.g. so we can tell if a pattern is simply for destructuring, or if it actually declares a new
variable).</li>
<li>E.g. the declaration <code>any: (x, y) = (1, 1.5)</code> will be such that
<ul>
<li><code>(x, y)</code> is a <code>PatternTy::Destructuring(tuple(int, float))</code></li>
<li><code>x</code> is a <code>PatternTy::Variable(int)</code></li>
<li><code>y</code> is a <code>PatternTy::Variable(float)</code></li>
</ul>
</li>
</ul>
</li>
<li>The <code>name_resolution(ident)</code> method finds the <code>PatternRef</code> for an expression which is an identifier (e.g. identifier
pointing to a variable).</li>
<li>The <code>pattern_resolution(ident)</code> method finds the <code>PatternRef</code> for a pattern which is an identifier (e.g. enum atom
used in a case expression pattern)</li>
</ul>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Typing of expressions is done recursively, using the types of child expressions
to determine the type of the outer expression.</p>
<p>For example, the expression <code>([1, 2.5], 3)</code> will be typed by:</p>
<ul>
<li>The first expression is a tuple, so visit its child fields
<ul>
<li>The first tuple field is an array literal so visit the child members
<ul>
<li>The first child member is an integer literal, so its type is <code>int</code></li>
<li>The second child member is a float literal, so its type is <code>float</code></li>
</ul>
</li>
<li>Therefore the array literal is determined to have type
<code>array [int] of float</code> as float is the most specific supertype of <code>int</code> and
<code>float</code>.</li>
<li>The second tuple field is an integer literal, so its type is <code>int</code></li>
</ul>
</li>
<li>Therefore the tuple is of type <code>tuple(array [int] of float, int)</code></li>
</ul>
<h3 id="calls"><a class="header" href="#calls">Calls</a></h3>
<p>One exception to bottom-up typing occurs when dealing with calls, as in order to perform overloading resolution, we
must specially handle the case of a call with an identifier callee. See the following section on function resolution
for more detail.</p>
<p>For example, the call <code>foo(1, &quot;a&quot;)</code> would be typed by:</p>
<ul>
<li>Getting the types of each argument (in this case <code>int</code> and <code>string</code>)</li>
<li>Finding all the function items named <code>foo</code></li>
<li>Performing overloading resolution given the argument types</li>
<li><code>foo</code> is given the type of the operation</li>
<li>The call is given the return type of the operation</li>
</ul>
<p>If the call does not have an identifier as its callee, the callee type is determined in the usual bottom-up fashion, and
no overloading resolution is required.</p>
<h3 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h3>
<p>Identifier expressions cause the type checker to lookup the identifier in the expression's <a href="./scope.html">scope</a>, and
fetch the type signature of the retrieve pattern's item to determine the type of the identifier. For bodies, we can
fetch the signature of the item directly (and reuse the computation of that signature if it's already done), but for
signatures which depend on other signatures, we do not do this because of the possibility of cycles.</p>
<p>Instead, the signatures of the dependencies are always computed, and if we reach the initiating signature during this
process, we can break out of the cycle and return the error type (at that stage, not at the initiating site). Any
cyclic definition errors will be emitted later during topological sorting. This is important for dealing with function
signatures that include calls to other overloads of the function, since these should work, but resolving the overloaded
call would require the type of 'this' signature, which is in the middle of being computed.</p>
<h2 id="ascribed-types"><a class="header" href="#ascribed-types">Ascribed types</a></h2>
<p>Typing user-written types (the HIR <code>Type</code>) involves computing the concrete type (<code>Ty</code>) they represent. For example, the
type <code>var 1..3</code> is typed by computing the type of the domain <code>1..3</code>. Since it is a <code>set of int</code>, then the variable is an
<code>int</code> type, and since the type has the <code>var</code> modifier, the complete type is computed to be <code>var int</code>.</p>
<p>Typing these becomes more complex when dealing with incomplete types. In these cases, we always have a RHS expression
which can be typed first, and then we can use this computed type to fill in the 'holes' in the ascribed type.</p>
<p>For example, consider the (contrived) declaration:</p>
<pre><code class="language-mzn">array [_] of var set of any: x = [{1, 2}];
</code></pre>
<p>In this case, we start by computing the type of the RHS, and determine it to be of type <code>array [int] of set of int</code>.
This type is unified with the ascribed type to obtain the type <code>array [int] of var set of int</code> for <code>x</code>.</p>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<p>Typing of patterns is done top-down, based on an already computed type that the pattern must take. For example, to type
the declaration</p>
<pre><code class="language-mzn">tuple(var int, any): (a, b) = (1, 2.5);
</code></pre>
<ul>
<li>The concrete type of the declaration is <code>tuple(var int, float)</code>
(found by computing the type of the RHS and using it to fill in hole in the
LHS type)</li>
<li>Therefore, the root pattern <code>(a, b)</code> has type <code>tuple(var int, float)</code>.</li>
<li>We then visit the child patterns and set their type to the corresponding tuple
field type.</li>
<li>So <code>a</code> has type <code>var int</code></li>
<li>And <code>b</code> has type <code>float</code></li>
</ul>
<p>One complication is that when dealing with constructor calls in patterns, we only know the 'return type' of the call, as
we know the type of the call pattern itself, but not its arguments. We use this return type to determine the what the
actual constructor call must be. For example:</p>
<pre><code class="language-mzn">enum Foo = A(Bar) ++ {B, C};
enum Bar = {D, E};
var Foo: x;
any: y = case x of
    A(v) =&gt; v,
    _ =&gt; E
endcase;
</code></pre>
<ul>
<li>The type of <code>x</code> is <code>var Foo</code></li>
<li>Therefore the type of the first case pattern <code>A(v)</code> is also <code>var Foo</code>
<ul>
<li>So based on that, we must be using the constructor <code>var Foo: A(var Bar)</code>, and so this is the type of the <code>A</code> pattern</li>
<li>The type of <code>v</code> is therefore <code>var Bar</code></li>
<li>So the result for the first case arm is <code>var Bar</code></li>
</ul>
</li>
<li>The second case pattern <code>_</code> should also match the type of <code>x</code> (<code>var Bar</code>)
<ul>
<li>Its result type is <code>E</code>, which is the type <code>Bar</code></li>
<li>So the case expression is of type <code>var Bar</code></li>
</ul>
</li>
</ul>
<h2 id="function-resolution"><a class="header" href="#function-resolution">Function resolution</a></h2>
<p>Function resolution involves determining a call identifier and a list of argument <code>Ty</code>s, the best matching overload to
use (if there is one). The algorithm used is:</p>
<ul>
<li>If there is a variable which is an <code>op</code> function with the correct name, use it.</li>
<li>If not, then find the function items in scope with the correct name.</li>
<li>Remove any candidates which have an incorrect number of arguments.</li>
<li>Remove any candidates which cannot be instantiated with the argument <code>Ty</code>s</li>
<li>For every pair of candidates <code>a</code>, and <code>b</code> remaining, eliminate the 'less specific' function
<ul>
<li>Instantiate <code>a</code> and <code>b</code> with our call's argument types</li>
<li>If the instantiated argument types of <code>a</code> are all subtypes of the instantiated argument types of <code>b</code>, but not the
other way around, then eliminate <code>b</code> (and vice-versa).</li>
<li>If both instantiated argument types are equivalent, then
<ul>
<li>If <code>a</code> is polymorphic but <code>b</code> is a concrete function, then eliminate <code>a</code> (and vice-versa)</li>
<li>If both candidates are polymorphic, then
<ul>
<li>If <code>a</code> can be instantiated with <code>b</code>'s (original) parameter types, but not the other way around, eliminate <code>a</code>
(and vice-versa)</li>
</ul>
</li>
<li>If <code>a</code> has a body but <code>b</code> doesn't, eliminate <code>b</code> (and vice-versa)</li>
</ul>
</li>
<li>Otherwise arbitrarily eliminate <code>a</code></li>
</ul>
</li>
</ul>
<p>Essentially, we choose such that:</p>
<ul>
<li>More specific parameter types are preferred: <code>bool</code> over <code>int</code>, <code>int</code> over <code>var int</code>. We take the instantiated
argument types into account, so a function taking <code>$$E</code> will be preferred over a function taking <code>float</code> if called
with an <code>int</code> argument.</li>
<li>Where two candidates would instantiate to the same types, prefer <code>$$E</code> functions over <code>$T</code> functions, and prefer
concrete types over either of those.</li>
</ul>
<p>It is an error if we are left with more than one candidate, or no candidates at the end of the process. Additionally,
it should be noted that in the case of two identical functions which have bodies, we will simply arbitrarily choose one
at this stage to allow type checking to continue with a reasonable return type. The duplicate function error will be
emitted during final validation of the HIR.</p>
<h3 id="type-inst-variables"><a class="header" href="#type-inst-variables">Type-inst variables</a></h3>
<p>There are two kinds of type-inst variables: <code>$T</code> and <code>$$E</code>. <code>$T</code> matches any type other than arrays and functions (this
is because the old compiler doesn't accept arrays for these, but actually it seems like it would make more sense if it
did). <code>$$E</code> matches any enumerable type (booleans, integers, enums) - unlike the old compiler, this is a a properly
generic type parameter, and is not considered to a special <code>int</code>.</p>
<p>It's also possible to restrict <code>$T</code> to accept only types valid for array indices if it is used as <code>array [$T] of int</code>.
In this case only integers/enums or tuples of them would be accepted.</p>
<p>One complication is that the way type-inst variables are used looks different to most other languages. Since omitting
<code>var</code>/<code>opt</code> implies <code>par</code>, non-<code>opt</code>, a parameter declared to be <code>$T</code> is actually <code>par (non-opt) $T</code>. That is, the
parameter will accept the par, non-optional version of whatever type the type parameter <code>$T</code> is given as. <code>any $T</code> is
used to make the parameter accept the actual type of the type parameter <code>$T</code>.</p>
<p>Note that the language is currently missing <code>anyvar</code> and <code>anyopt</code>, which would be needed for expressing parameters
whose inst/optionality depend on the input type parameters (for type-inst variables used in parameters only, this is
not really a problem since using <code>var $T</code> or <code>opt $T</code> will still let you match the needed combinations - the problem
is that if you use the type-inst variable in the return type, specifying <code>opt $T</code> will force the return type to be
<code>opt</code>, even if <code>$T</code> is non-optional).</p>
<h4 id="determining-the-types-substituted-for-type-inst-variables"><a class="header" href="#determining-the-types-substituted-for-type-inst-variables">Determining the types substituted for type-inst variables</a></h4>
<p>Since calls do not explicitly set the types to give for each type-inst variable, we have to use the argument types to
determine them. Consider the function:</p>
<pre><code class="language-mzn">function var opt $T: foo(var $T: x, any $T: y);
var 1..3: p;
opt int: q;
any: v = foo(p, q);
</code></pre>
<p>Then for the call <code>foo(p, q)</code> we start by considering the first argument <code>p</code>, which is of type <code>var int</code>. The function
parameter is declared as <code>var $T</code>, so that means it applies its own inst (<code>var</code>) and optionality (non-<code>opt</code>) to the type
of <code>$T</code> - therefore we strip off the inst and optionality from the given argument type and use that for <code>$T</code>. So
<code>$T</code> for this argument is set to be (<code>par</code>, non-<code>opt</code>) <code>int</code>.</p>
<p>Next we look at the second argument <code>q</code>, which is of type <code>opt int</code>. Since the function parameter is declared as
<code>any $T</code>, it does not apply any modifiers to the type of <code>$T</code>, so we set the type of <code>$T</code> for this argument to be
<code>opt int</code>.</p>
<p>Then the final type for <code>$T</code> is the most specific supertype of <code>int</code> and <code>opt int</code>, meaning the final type is <code>opt int</code>.
From this, we can compute the actual instantiated function signature by substituting <code>$T</code> = <code>opt int</code> for the parameters
and return type.</p>
<ul>
<li>The first parameter <code>var $T</code> becomes <code>var int</code> (again, since <code>var $T</code> is really <code>var</code>, non-<code>opt</code> <code>$T</code>).</li>
<li>The second parameter of <code>any $T</code> gives <code>opt int</code> (since <code>any</code> means don't apply any modifiers to <code>$T</code>).</li>
<li>The return type of <code>var opt $T</code> gives <code>var opt int</code> (since it applies the <code>var</code> and <code>opt</code> modifiers to <code>$T</code>).</li>
</ul>
<p>So the instantiated result is:</p>
<pre><code class="language-mzn">function var opt int: foo(var int: x, opt int: y);
var 1..3: p;
opt int: q;
var opt int: v = foo(p, q);
</code></pre>
<h2 id="output-typing"><a class="header" href="#output-typing">Output typing</a></h2>
<p>The expressions of output items, and definitions of <code>:: output_only</code> declarations are type-checked in a special mode
where the types of top-level identifiers are assumed to be par. This alleviates the need to manually insert calls to
<code>fix()</code>.</p>
<p>In this example, if we don't consider <code>p</code> in the output statement to be <code>par</code>, then the if-then-else will cause will
trigger a type error as it will return the illegal type <code>var string</code>.</p>
<pre><code class="language-mzn">var bool: p;
output [if p then &quot;Yes&quot; else &quot;No&quot; endif];
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../compilation/hir/scope.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../compilation/thir/thir.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../compilation/hir/scope.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../compilation/thir/thir.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/mzn-highlight.js"></script>


    </div>
    </body>
</html>
